module alu_adder (
    input clk,  // clock
    input rst,  // reset
    output out,    
    input a [8], 
    input b [8], 
    output calculated_output [8], 
    input alu_fn [2],
    output z,
    output v,
    output n
  ) {
//  var count;
sig xb [8];
sig sumOut [8];

  always {
    // a[7] and b[7] are the signed bits
    out = 0; 
    sumOut = 8b0;
    xb = (32x{alu_fn[0]})^b;
    
    if(alu_fn[1] == 0){
      sumOut = a+xb+alu_fn[0];    
    }
    else if(alu_fn == b10){   //multiply??
      sumOut = a*b;
    } 
/*
    if(alu_fn == b01){ //subtract
      sumOut = a+(~b+1);
    }
    else if(alu_fn == b00){ //add
      sumOut = a+b;
    }
*/
    calculated_output = sumOut;
    
    if(sumOut == 0) z = 1;
    else z = 0;
    n = sumOut[7];
    v = (a[7]&xb[7]&~sumOut[7])|(!a[7]&~xb[7]&sumOut[7]); 
    //instead of this, we can check if sumOut is more than 8 bits long
    //might not work if the 9th bit would be a 0, would have to compare the initial MSB.
  }
}
